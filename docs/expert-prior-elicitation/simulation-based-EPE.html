<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.8.24">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>simulation-based-epe</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */
  vertical-align: middle;
}
</style>


<script src="simulation-based-EPE_files/libs/clipboard/clipboard.min.js"></script>
<script src="simulation-based-EPE_files/libs/quarto-html/quarto.js" type="module"></script>
<script src="simulation-based-EPE_files/libs/quarto-html/tabsets/tabsets.js" type="module"></script>
<script src="simulation-based-EPE_files/libs/quarto-html/axe/axe-check.js" type="module"></script>
<script src="simulation-based-EPE_files/libs/quarto-html/popper.min.js"></script>
<script src="simulation-based-EPE_files/libs/quarto-html/tippy.umd.min.js"></script>
<script src="simulation-based-EPE_files/libs/quarto-html/anchor.min.js"></script>
<link href="simulation-based-EPE_files/libs/quarto-html/tippy.css" rel="stylesheet">
<link href="simulation-based-EPE_files/libs/quarto-html/quarto-syntax-highlighting-dc55a5b9e770e841cd82e46aadbfb9b0.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="simulation-based-EPE_files/libs/bootstrap/bootstrap.min.js"></script>
<link href="simulation-based-EPE_files/libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="simulation-based-EPE_files/libs/bootstrap/bootstrap-9e3ffae467580fdb927a41352e75a2e0.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="light">

  <script src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN" && texText && texText.data) {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

</head>

<body class="fullcontent quarto-light">

<div id="quarto-content" class="page-columns page-rows-contents page-layout-article">

<main class="content" id="quarto-document-content">




<section id="simulation-based-expert-prior-elicitation" class="level1">
<h1>Simulation-based expert prior elicitation</h1>
<section id="high-level-idea" class="level2">
<h2 class="anchored" data-anchor-id="high-level-idea">High-level idea</h2>
<p>In Bockting et al.&nbsp;(2024), we propose an expert prior elicitation (EPE) method that builds upon recent advances in the field of <strong>predictive prior elicitation</strong> by Manderson (2023), da Silva et al (2023), and Hartmann and Agiashvili (2020). Our approach extends this line of research by introducing a <strong>hybrid framework</strong> that allows target quantities to be specified in both the parameter space and the observable space. Furthermore, the method supports custom specifications of generative models, target quantities, and elicitation techniques, enabled by its modular design and simulation-based approach.</p>
<div class="{note}">
<p>The core logic of our EPE method can be summarized in a five-step workflow:</p>
<ol type="1">
<li><strong>Define the generative model</strong>: Specify the generative model, including the functional form of the data distribution and the parametric family of prior distributions.</li>
<li><strong>Define target quantities and elicitation techniques</strong>: Select the set of target quantities and determine the elicitation techniques to query the expert (cf.&nbsp;elicited summaries).</li>
<li><strong>Simulate elicited summaries</strong>: Draw samples from the generative model and compute the corresponding set of simulated elicited summaries.</li>
<li><strong>Evaluate discrepancy between simulated and expert-elicited summaries</strong>: Assess the discrepancy between the simulated and expert-elicited summaries using a multi-objective loss function.</li>
<li><strong>Adjust prior hyperparameters to minimize discrepancy</strong>: Apply an optimization scheme to update the prior hyperparameters such that the loss function is minimized.</li>
</ol>
</div>
<p>The following figure provides a <strong>conceptual visualization</strong> of this worklow within the <a href="EPE-process.md">EPE process</a>.</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="../graphics/conceptual-workflow.png" class="img-fluid figure-img"></p>
<figcaption>conceptual workflow</figcaption>
</figure>
</div>
</section>
<section id="formalization" class="level2">
<h2 class="anchored" data-anchor-id="formalization">Formalization</h2>
<p>The definition of the generative model <span class="math inline">\(\mathcal{M}\)</span> comprises the data distribution, <span class="math inline">\(p(y \mid \theta)\)</span>, and the specification of parametric prior distribution families, <span class="math inline">\(p(\theta \mid \lambda)\)</span>. In the formulation presented in the subsequent Equation, we additionally introduce a vector of derived model parameters, <span class="math inline">\(\eta\)</span>, and derived model outcomes, <span class="math inline">\(z\)</span>, which are defined as transformations of the model parameters, <span class="math inline">\(f_j^\text{par}(\theta_j)\)</span>, and the model outcomes, <span class="math inline">\(f^\text{dat}(y)\)</span>, respectively: <span class="math display">\[\begin{align}\label{eq: generative-model}
\begin{split}
\left.
\begin{aligned}
    \theta &amp;\sim p(\theta \mid \lambda) \\
    \eta_j &amp;=f_j^\text{par}(\theta_j)
\end{aligned}
\right\} &amp; \quad \text{parameter space} \\
\left.
\begin{aligned}
    y &amp;\sim p(y \mid b,\eta) \\
    z &amp;= f^\text{dat}(y)
\end{aligned}
\right\} &amp; \quad \text{observable space} \\
\end{split}
\end{align}\]</span> with <span class="math inline">\(\eta = (\eta_1,\ldots,\eta_J)\)</span> and <span class="math inline">\(b\)</span> denotes a vector of potential covariates within a regression context. Consequently, given a set of hyperparameter values <span class="math inline">\(\lambda\)</span>, the generative model can be executed in forward mode to draw a total of <span class="math inline">\(S\)</span> samples (<span class="math inline">\(s=1,\ldots,S\)</span>) for the parameters (<span class="math inline">\(\theta^{(s)},\eta^{(s)}\)</span>) and observables (<span class="math inline">\(y^{(s)},z^{(s)}\)</span>) specified by <span class="math inline">\(\mathcal{M}\)</span>.</p>
<section id="target-quantities" class="level3">
<h3 class="anchored" data-anchor-id="target-quantities">Target quantities</h3>
<p>Besides the generative model, it is necessary to formalize the selected set of . A target quantity is defined as a random variable <span class="math inline">\(T \in \mathfrak{T}\)</span> distributed according to <span class="math inline">\(p_T\)</span> <span class="math display">\[\begin{equation}
T \sim p_T,
\end{equation}\]</span> where <span class="math inline">\(T\)</span> may refer to any quantity in the parameter space, the observable space, or any transformation thereof, i.e., <span class="math inline">\(\mathfrak{T} = \phi_\Theta(\Theta) \cup \phi_{\mathcal{Y}}(\mathcal{Y})\)</span> with <span class="math inline">\(\phi_\Theta, \phi_{\mathcal{Y}}\)</span> denoting arbitrary transformations of the respective spaces. Using the previously introduced notation, the different types of target quantities can be represented as <span class="math display">\[\begin{align*}\label{eq: target-quantities}
    T&amp;: \theta \sim p(\theta \mid \lambda) \quad\text{(parameter)} &amp;T: y \sim p(y \mid b,\lambda) &amp;\quad\text{(outcome)}\\
    T&amp;:\eta \sim p(\eta \mid \lambda) \quad\text{(deriv. parameter)}  &amp;T: z \sim p(z \mid b, \lambda) &amp;\quad\text{(deriv. outcome)}
\end{align*}\]</span> Instead of directly employing the density <span class="math inline">\(p_T\)</span>, our simulation-based approach involves sampling from the generative model yielding realizations drawn from <span class="math inline">\(p_T\)</span> <span class="math display">\[\begin{equation}
\{t^{(s)}\}_{s=1}^S \sim p_T(t \mid \lambda).
\end{equation}\]</span> Typically, a of <span class="math inline">\(P\)</span> target quantities is defined, resulting in a vector of samples for each defined target quantity, <span class="math inline">\(\{t_p^{(s)}\}_{s\in \mathbb N, p\in \mathbb N}\)</span>.</p>
</section>
<section id="elicitation-techniques" class="level3">
<h3 class="anchored" data-anchor-id="elicitation-techniques">Elicitation techniques</h3>
<p>Given the set of target quantities, the next step is to formalize these quantities are queried from an expert, that is, to define the corresponding . For each of the <span class="math inline">\(P\)</span> target quantities <span class="math inline">\(Q_p\)</span> elicitation techniques <span class="math inline">\(f_{p,q}\)</span> are specified with <span class="math inline">\(q=1,\ldots, Q_p\)</span>. An elicitation technique applied to a target quantity yields in an elicited summary <span class="math display">\[\begin{equation}
    E_m = f_{p,q}\left(\{t_p^{(s)}\}_{s=1}^S\right) \quad \text{for } p=1,\ldots,P.
\end{equation}\]</span> The index <span class="math inline">\(m=1,\ldots,M\)</span> arises from the combination of target quantities and the elicitation techniques specified for each target quantity. For instance, consider two target quantities, <span class="math inline">\(\{t_1^{(s)}\}\)</span> and <span class="math inline">\(\{t_2^{(s)}\}\)</span>. Suppose the median, <span class="math inline">\(\text{MED}(\{t_1^{(s)}\})\)</span>, is elicited for <span class="math inline">\(\{t_1^{(s)}\}\)</span>, while the 25th, 50th, and 75th percentiles, <span class="math inline">\(Q_{25}(\{t_2^{(s)}\})\)</span>, <span class="math inline">\(Q_{50}(\{t_2^{(s)}\})\)</span>, and <span class="math inline">\(Q_{75}(\{t_2^{(s)}\})\)</span>, are elicited for <span class="math inline">\(\{t_2^{(s)}\}\)</span>. In this case, the total number of elicited summaries is <span class="math inline">\(M = 4\)</span>. An elicited summary <span class="math inline">\(E_m\)</span> may take the form of a scalar, for example, when the median or a quantile of a target quantity is elicited, or a vector. The final set of elicited summaries is denoted by <span class="math inline">\(\{E_m\}_{m=1}^M\)</span>.</p>
</section>
<section id="discrepancy-measure" class="level3">
<h3 class="anchored" data-anchor-id="discrepancy-measure">Discrepancy measure</h3>
<p>Once the generative model <span class="math inline">\(\mathcal M\)</span>, target quantities <span class="math inline">\(\{t_p^{(s)}\}\)</span>, and elicitation techniques <span class="math inline">\(f_{p,q}\)</span> are specified, the corresponding samples can be generated in forward mode for a given <span class="math inline">\(\lambda\)</span>. This procedure results in the set of simulated summaries <span class="math inline">\(\{E_m\}_{m=1}^M\)</span>. Subsequently, the discrepancy between each pair of simulated and expert-elicited summaries is computed via a discrepancy measure <span class="math inline">\(\mathcal D_m\)</span>, which may vary across the elicited summaries <span class="math inline">\(\{E_m\}_{m=1}^M\)</span>. For clarity, we introduced a slightly adjusted notation to differentiate between simulated data (i.e., the simulated elicited summaries), denoted by <span class="math inline">\(\tilde E_m\)</span>, and observed data (i.e., the expert-elicited summaries), denoted by <span class="math inline">\(\dot E_m\)</span>. We further use <span class="math inline">\(\tilde{E}_m(\lambda)\)</span> to explicitly show the functional dependence of the simulated summaries on the hyperparameters <span class="math inline">\(\lambda\)</span>, which are subject to the optimization procedure. The discrepancy between the simulated and expert-elicited summaries can then be denoted by <span class="math display">\[\begin{equation}
    \mathcal D_{m'}(\tilde{E}_{m'}(\lambda), \dot{E}_{m'})
\end{equation}\]</span> where <span class="math inline">\(\mathcal D_{m'}\)</span> denotes the chosen discrepancy measure. A new index, <span class="math inline">\(m'=1,\ldots, M'\)</span>, is introduced to account for the possibility of concatenating multiple elicited summaries into a single representation. For example, revisiting the case described above, the three elicited quantiles for <span class="math inline">\(\{t_2^{(s)}\}\)</span> may be concatenated into a single vector. In this case, the total number of loss components is reduced, yielding <span class="math inline">\(m' = 1,2\)</span>. However, the impact of concatenating elicited statistics on the optimization results is not yet fully understood and warrants further investigation.</p>
</section>
<section id="multi-objective-loss-function" class="level3">
<h3 class="anchored" data-anchor-id="multi-objective-loss-function">Multi-objective loss function</h3>
<p>To obtain a single loss value, the individual discrepancy measures, <span class="math inline">\(\mathcal D_{m'}\)</span> (also referred to as ), are combined via a denoted by <span class="math inline">\(\mathcal L(\lambda)\)</span>. As aggregation method, a weighted sum is employed, with weights <span class="math inline">\(\gamma_{m'}\)</span> assigned to each discrepancy measure <span class="math inline">\(\mathcal D_{m'}\)</span> <span class="math display">\[\begin{equation}\label{eq: weighted-sum}
    \mathcal L(\lambda) = \sum_{{m'}=1}^{M'} \gamma_{m'}\cdot\mathcal D_{m'}(\dot{E}_{m'}(\lambda), \tilde{E}_{m'}).
\end{equation}\]</span> Under this loss formulation, the optimization objective is to determine the hyperparameters <span class="math inline">\(\lambda^*\)</span> that minimize the multi-objective loss, thereby reducing the overall discrepancy between the simulated and expert-elicited summaries <span class="math display">\[\begin{equation}\label{eq: minimization-objective}
    \lambda^* := \arg \min_\lambda \mathcal L(\lambda).
\end{equation}\]</span></p>
</section>
<section id="gradient-based-optimization" class="level3">
<h3 class="anchored" data-anchor-id="gradient-based-optimization">Gradient-based optimization</h3>
<p>The current procedure for solving the introduced objective utilizes an iterative approach. In each iteration (or epoch), a set of simulated elicited summaries is derived based on the current hyperparameter vector <span class="math inline">\(\lambda^{\text{epoch}}\)</span>. The discrepancy between these simulated and the expert-elicited summaries is then computed and aggregated to yield a total loss value, which subsequently drives the update of the hyperparameters <span class="math inline">\(\lambda\)</span> <span class="math display">\[\begin{align}
\lambda^{\text{epoch}} = \lambda^{\text{epoch}-1} - \delta \frac{\partial \mathcal{L}}{\partial \lambda},
\end{align}\]</span> where <span class="math inline">\(\delta\)</span> denotes the learning rate. The updated hyperparameters are then used to simulate a new set of summaries, which enters the next loss computation. This updating procedure continues until a convergence criterion is satisfied. To implement this optimization procedure, we employ mini-batch stochastic gradient descent with automatic differentiation, facilitated by the reparameterization trick .</p>
</section>
</section>
</section>

</main>
<!-- /main column -->
<script id="quarto-html-after-body" type="application/javascript">
  window.document.addEventListener("DOMContentLoaded", function (event) {
    const icon = "î§‹";
    const anchorJS = new window.AnchorJS();
    anchorJS.options = {
      placement: 'right',
      icon: icon
    };
    anchorJS.add('.anchored');
    const isCodeAnnotation = (el) => {
      for (const clz of el.classList) {
        if (clz.startsWith('code-annotation-')) {
          return true;
        }
      }
      return false;
    }
    const onCopySuccess = function(e) {
      // button target
      const button = e.trigger;
      // don't keep focus
      button.blur();
      // flash "checked"
      button.classList.add('code-copy-button-checked');
      var currentTitle = button.getAttribute("title");
      button.setAttribute("title", "Copied!");
      let tooltip;
      if (window.bootstrap) {
        button.setAttribute("data-bs-toggle", "tooltip");
        button.setAttribute("data-bs-placement", "left");
        button.setAttribute("data-bs-title", "Copied!");
        tooltip = new bootstrap.Tooltip(button,
          { trigger: "manual",
            customClass: "code-copy-button-tooltip",
            offset: [0, -8]});
        tooltip.show();
      }
      setTimeout(function() {
        if (tooltip) {
          tooltip.hide();
          button.removeAttribute("data-bs-title");
          button.removeAttribute("data-bs-toggle");
          button.removeAttribute("data-bs-placement");
        }
        button.setAttribute("title", currentTitle);
        button.classList.remove('code-copy-button-checked');
      }, 1000);
      // clear code selection
      e.clearSelection();
    }
    const getTextToCopy = function(trigger) {
      const outerScaffold = trigger.parentElement.cloneNode(true);
      const codeEl = outerScaffold.querySelector('code');
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
    const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
      text: getTextToCopy
    });
    clipboard.on('success', onCopySuccess);
    if (window.document.getElementById('quarto-embedded-source-code-modal')) {
      const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
        text: getTextToCopy,
        container: window.document.getElementById('quarto-embedded-source-code-modal')
      });
      clipboardModal.on('success', onCopySuccess);
    }
      var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
      var mailtoRegex = new RegExp(/^mailto:/);
        var filterRegex = new RegExp('/' + window.location.host + '/');
      var isInternal = (href) => {
          return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
      }
      // Inspect non-navigation links and adorn them if external
     var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
      for (var i=0; i<links.length; i++) {
        const link = links[i];
        if (!isInternal(link.href)) {
          // undo the damage that might have been done by quarto-nav.js in the case of
          // links that we want to consider external
          if (link.dataset.originalHref !== undefined) {
            link.href = link.dataset.originalHref;
          }
        }
      }
    function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
      const config = {
        allowHTML: true,
        maxWidth: 500,
        delay: 100,
        arrow: false,
        appendTo: function(el) {
            return el.parentElement;
        },
        interactive: true,
        interactiveBorder: 10,
        theme: 'quarto',
        placement: 'bottom-start',
      };
      if (contentFn) {
        config.content = contentFn;
      }
      if (onTriggerFn) {
        config.onTrigger = onTriggerFn;
      }
      if (onUntriggerFn) {
        config.onUntrigger = onUntriggerFn;
      }
      window.tippy(el, config);
    }
    const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
    for (var i=0; i<noterefs.length; i++) {
      const ref = noterefs[i];
      tippyHover(ref, function() {
        // use id or data attribute instead here
        let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
        try { href = new URL(href).hash; } catch {}
        const id = href.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note) {
          return note.innerHTML;
        } else {
          return "";
        }
      });
    }
    const xrefs = window.document.querySelectorAll('a.quarto-xref');
    const processXRef = (id, note) => {
      // Strip column container classes
      const stripColumnClz = (el) => {
        el.classList.remove("page-full", "page-columns");
        if (el.children) {
          for (const child of el.children) {
            stripColumnClz(child);
          }
        }
      }
      stripColumnClz(note)
      if (id === null || id.startsWith('sec-')) {
        // Special case sections, only their first couple elements
        const container = document.createElement("div");
        if (note.children && note.children.length > 2) {
          container.appendChild(note.children[0].cloneNode(true));
          for (let i = 1; i < note.children.length; i++) {
            const child = note.children[i];
            if (child.tagName === "P" && child.innerText === "") {
              continue;
            } else {
              container.appendChild(child.cloneNode(true));
              break;
            }
          }
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(container);
          }
          return container.innerHTML
        } else {
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(note);
          }
          return note.innerHTML;
        }
      } else {
        // Remove any anchor links if they are present
        const anchorLink = note.querySelector('a.anchorjs-link');
        if (anchorLink) {
          anchorLink.remove();
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        if (note.classList.contains("callout")) {
          return note.outerHTML;
        } else {
          return note.innerHTML;
        }
      }
    }
    for (var i=0; i<xrefs.length; i++) {
      const xref = xrefs[i];
      tippyHover(xref, undefined, function(instance) {
        instance.disable();
        let url = xref.getAttribute('href');
        let hash = undefined;
        if (url.startsWith('#')) {
          hash = url;
        } else {
          try { hash = new URL(url).hash; } catch {}
        }
        if (hash) {
          const id = hash.replace(/^#\/?/, "");
          const note = window.document.getElementById(id);
          if (note !== null) {
            try {
              const html = processXRef(id, note.cloneNode(true));
              instance.setContent(html);
            } finally {
              instance.enable();
              instance.show();
            }
          } else {
            // See if we can fetch this
            fetch(url.split('#')[0])
            .then(res => res.text())
            .then(html => {
              const parser = new DOMParser();
              const htmlDoc = parser.parseFromString(html, "text/html");
              const note = htmlDoc.getElementById(id);
              if (note !== null) {
                const html = processXRef(id, note);
                instance.setContent(html);
              }
            }).finally(() => {
              instance.enable();
              instance.show();
            });
          }
        } else {
          // See if we can fetch a full url (with no hash to target)
          // This is a special case and we should probably do some content thinning / targeting
          fetch(url)
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.querySelector('main.content');
            if (note !== null) {
              // This should only happen for chapter cross references
              // (since there is no id in the URL)
              // remove the first header
              if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
                note.children[0].remove();
              }
              const html = processXRef(null, note);
              instance.setContent(html);
            }
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      }, function(instance) {
      });
    }
        let selectedAnnoteEl;
        const selectorForAnnotation = ( cell, annotation) => {
          let cellAttr = 'data-code-cell="' + cell + '"';
          let lineAttr = 'data-code-annotation="' +  annotation + '"';
          const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
          return selector;
        }
        const selectCodeLines = (annoteEl) => {
          const doc = window.document;
          const targetCell = annoteEl.getAttribute("data-target-cell");
          const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
          const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
          const lines = annoteSpan.getAttribute("data-code-lines").split(",");
          const lineIds = lines.map((line) => {
            return targetCell + "-" + line;
          })
          let top = null;
          let height = null;
          let parent = null;
          if (lineIds.length > 0) {
              //compute the position of the single el (top and bottom and make a div)
              const el = window.document.getElementById(lineIds[0]);
              top = el.offsetTop;
              height = el.offsetHeight;
              parent = el.parentElement.parentElement;
            if (lineIds.length > 1) {
              const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
              const bottom = lastEl.offsetTop + lastEl.offsetHeight;
              height = bottom - top;
            }
            if (top !== null && height !== null && parent !== null) {
              // cook up a div (if necessary) and position it
              let div = window.document.getElementById("code-annotation-line-highlight");
              if (div === null) {
                div = window.document.createElement("div");
                div.setAttribute("id", "code-annotation-line-highlight");
                div.style.position = 'absolute';
                parent.appendChild(div);
              }
              div.style.top = top - 2 + "px";
              div.style.height = height + 4 + "px";
              div.style.left = 0;
              let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
              if (gutterDiv === null) {
                gutterDiv = window.document.createElement("div");
                gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
                gutterDiv.style.position = 'absolute';
                const codeCell = window.document.getElementById(targetCell);
                const gutter = codeCell.querySelector('.code-annotation-gutter');
                gutter.appendChild(gutterDiv);
              }
              gutterDiv.style.top = top - 2 + "px";
              gutterDiv.style.height = height + 4 + "px";
            }
            selectedAnnoteEl = annoteEl;
          }
        };
        const unselectCodeLines = () => {
          const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
          elementsIds.forEach((elId) => {
            const div = window.document.getElementById(elId);
            if (div) {
              div.remove();
            }
          });
          selectedAnnoteEl = undefined;
        };
          // Handle positioning of the toggle
      window.addEventListener(
        "resize",
        throttle(() => {
          elRect = undefined;
          if (selectedAnnoteEl) {
            selectCodeLines(selectedAnnoteEl);
          }
        }, 10)
      );
      function throttle(fn, ms) {
      let throttle = false;
      let timer;
        return (...args) => {
          if(!throttle) { // first call gets through
              fn.apply(this, args);
              throttle = true;
          } else { // all the others get throttled
              if(timer) clearTimeout(timer); // cancel #2
              timer = setTimeout(() => {
                fn.apply(this, args);
                timer = throttle = false;
              }, ms);
          }
        };
      }
        // Attach click handler to the DT
        const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
        for (const annoteDlNode of annoteDls) {
          annoteDlNode.addEventListener('click', (event) => {
            const clickedEl = event.target;
            if (clickedEl !== selectedAnnoteEl) {
              unselectCodeLines();
              const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
              if (activeEl) {
                activeEl.classList.remove('code-annotation-active');
              }
              selectCodeLines(clickedEl);
              clickedEl.classList.add('code-annotation-active');
            } else {
              // Unselect the line
              unselectCodeLines();
              clickedEl.classList.remove('code-annotation-active');
            }
          });
        }
    const findCites = (el) => {
      const parentEl = el.parentElement;
      if (parentEl) {
        const cites = parentEl.dataset.cites;
        if (cites) {
          return {
            el,
            cites: cites.split(' ')
          };
        } else {
          return findCites(el.parentElement)
        }
      } else {
        return undefined;
      }
    };
    var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
    for (var i=0; i<bibliorefs.length; i++) {
      const ref = bibliorefs[i];
      const citeInfo = findCites(ref);
      if (citeInfo) {
        tippyHover(citeInfo.el, function() {
          var popup = window.document.createElement('div');
          citeInfo.cites.forEach(function(cite) {
            var citeDiv = window.document.createElement('div');
            citeDiv.classList.add('hanging-indent');
            citeDiv.classList.add('csl-entry');
            var biblioDiv = window.document.getElementById('ref-' + cite);
            if (biblioDiv) {
              citeDiv.innerHTML = biblioDiv.innerHTML;
            }
            popup.appendChild(citeDiv);
          });
          return popup.innerHTML;
        });
      }
    }
  });
  </script>
</div> <!-- /content -->




</body></html>
